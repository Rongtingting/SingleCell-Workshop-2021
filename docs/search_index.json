[["index.html", "HKU Single-cell Workshop (Modules 4.2 &amp; 5) Chapter 1 Introduction 1.1 Contents of this part 1.2 Other modules of this workshop", " HKU Single-cell Workshop (Modules 4.2 &amp; 5) Yuanhua Lab: Mingze Gao, Rongting Huang, Xianjie Huang, Aaron Kwok, Zhuoxuan Li, Chen Qiao, Yuanhua Huang contact: yuanhua@hku.hk 2021-07-05 Chapter 1 Introduction This sub-tutorial book is for the Modules 4.2 and 5 of Single-cell Workshop at HKU. You can fork or download this tutorial book (and re-run it) from this GitHub repo: https://github.com/StatBiomed/SingleCell-Workshop-2021 1.1 Contents of this part Module 4.2: Cell trajectory inference Overview of trajectory inference RNA velocity Module 5: Cellular genetic analysis Nuclear and mtDNA SNV analysis in single-cell omics Copy number variation analysis from scRNA-seq 1.2 Other modules of this workshop Module 1: Introduction to R by Dr Joshua Ho &amp; lab (Online tutorials) Module 2: Fundamentals of scRNA-seq analysis by Dr Joshua Ho (Online tutorials) Module 3: Cell clustering and annotation by Dr Asif Javed (Online tutorials) Module 4.1: Cell interaction by Dr Asif Javed (Online tutorials) Note: to build this book, use the following script in R: bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],["env-pre.html", "Chapter 2 Prerequisites 2.1 R packages 2.2 Python packages", " Chapter 2 Prerequisites For reproducing the tutorials in the modules 4.2 and 5, we need a few R packages and a Python package. Detailed instructions are below. 2.1 R packages For module 4.2, we need reticulate to import the Python package (see next section. You can install it within R: # install reticulate for module 4.2 install.packages(&quot;reticulate&quot;) For module 5.1, we need cardelino, which is only available at GitHub, so we need to use devtools: # install devtools for module 5.1 install.packages(&#39;devtools&#39;) # install cardelino for module 5.1 devtools::install_github(&quot;single-cell-genetics/cardelino&quot;, build_vignettes = FALSE) For module 5.2, we need infercnv, which requires a standalone software JAGS. Please install JAGS manually for Windows or Mac from this link before install rjags R package: https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/ Continue and install rjags and infercnv: # install rjags for module 5.2 install.packages('rjags') # install inferCNV for module 5.2 if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;infercnv&quot;) 2.2 Python packages For module 4.2, we need one Python package scvelo. If you haven’t used Python before, we recommend installing it by using Anaconda, which contains Python 3.8 and various useful tools. 2.2.1 Installation on Windows Go to Anaconda webpage; click ‘Download’ button to download Anaconda for Windows (with Python3.8). Double click the downloaded file and install Anaconda following the instructions. (Note, this requires about 3G disk space) Open Anaconda Powershell Prompt and then install scVelo by typing this command in the shell: pip install scvelo==0.2.2 You have successfully set up the base environment of conda and installed the scVelo tool in this environment. 2.2.2 Installation on Linux Open Linux Shell. Download Anaconda installer with wget https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh Install Anaconda with bash Anaconda3-2021.05-Linux-x86_64.sh; follow the prompts on the installer screens. When you are asked Do you wish the installer to initialize Anaconda3 by running conda init, we recommend “yes.” Close and then re-open your Shell, to make the changes take effect. Install scVelo by typing this command in the shell: pip install scvelo==0.2.2 Type conda list in Shell. A list of installed packages appears if it has been installed correctly. 2.2.3 Installation on macOS In macOS, you could install Anaconda either in graphical mode or command line mode. Option 1: installation in Graphical Mode (recommended) This mode is very similar to Installation on Windows. Go to Anaconda webpage; click ‘Get Additional Installers’ button and then select the 64-Bit Graphical Installer for MacOS. Install Anaconda following the instructions. Open Terminal (you can type in Spotlight Search) and then install scVelo by typing this command in the shell: pip install scvelo==0.2.2 Option 2: installation in Command Line Mode This mode is very similar to Installation on Linux. Open macOS Terminal Download Anaconda installer with wget https://repo.anaconda.com/archive/Anaconda3-2021.05-MacOSX-x86_64.sh Install Anaconda with bash Anaconda3-2021.05-MacOSX-x86_64.sh; follow the prompts on the installer screens. When you are asked Do you wish the installer to initialize Anaconda3 by running conda init, we recommend “yes.” Close and then re-open your Shell, to make the changes take effect. Install scVelo by typing this command in the shell: pip install scvelo==0.2.2 Type conda list in Shell. A list of installed packages appears if it has been installed correctly. "],["RNA-velocity.html", "Chapter 3 Trajectory inference and RNA velocity 3.1 Introduction of trajectory inference 3.2 RNA velocity 3.3 RNA kinetics 3.4 Use scVelo package within R", " Chapter 3 Trajectory inference and RNA velocity 3.1 Introduction of trajectory inference Generally, an ideal dynamical analysis of a biological process is performing time-series experiment. However, the bottleneck may exist in the time resolution of the experiment, for example it is difficult to have a resolution shorter than a minute for RNA metabolic experiments. On the other hand, a snapshot of a population of cells (namely only single time point) can still capture different states of a biological process given cells have different speed in the process or even different fates. Usually, a snapshot representing a relatively transient dynamical process. Trajectory inference is type of computational methods to infer the latent time (or ordering) of a group of cells in a certain biological processes, for example cell cycle, cell differentiation, or response to an external stimuli. According to Wikipedia, “Trajectory inference or pseudotemporal ordering is a computational technique used in single-cell transcriptomics to determine the pattern of a dynamic process experienced by cells and then arrange cells based on their progression through the process.” Trajectory inference remains one of central interests in single-cell transcriptomics studies. Its popularity can be seen from large number of recently developed tools: in a recent benchmarking study published in Nature Biotechnology Saelens et al 2019, 45 out of more than 70 tools have been evaluated. The topology of the trajectory can be linear, multifurcation, cycle or even more complex. The performance of each method on different tasks or data sets varies a lot. We leave the readers to the original benchmark paper metioned above. Figure 3.1. Different trajectory topologies and its comparison. Fig. adapted from Saelens et al, 2019 Here, we only introduce two commonly used methods. Note, all above trajecotry inference methods are based on the current state of transcription and the distance between cell are symmetric, namely distance from cell A to cell B is the same as from cell B to cell A. Therefore, the direction of the inferred trajectory is either lack (namely require users to specify) or less reliable if using default setting. 3.1.1 Diffusion map Diffusion map is a type of non-linear dimension reduction methods, and is recently applied to estimate the pseudotime in single-cell transcriptomic data (Haghverdi et al 2016). As shown in Fig. 3.1 (adapted from Haghverdi et al 2016), this algorithm works with three steps: computing the overlap of local kernels at the expression levels of cells x and y. Diffusion pseudotime dpt(x,y) approximates the geodesic distance between x and y on the mapped manifold, Branching points are identified as points where anticorrelated distances from branch ends become correlated. Figure 3.1. Diffusion-map pseudotime. Fig. adapted from Haghverdi et al 2016 3.1.2 Monocle Another widely used tool is Monocle (now v3). One of cool features that Monocle3 offers is the branching in the trajectory. On the other hand, it generally requires users to specify the start (or end) point in the trajectory. Figure 3.1. Example results for Monocle3. Fig. adapted from its tutorial 3.2 RNA velocity 3.3 RNA kinetics As briefly mentioned that the trajectory inferred from the transcriptome ofter suffer from lack of automatically detected directionality of the trajectory. Very recently, the RNA velocity is a newly introduced concept to use the unspliced RNAs to indicate the transcriptional kinetic activity (La Manno et al, 2018), and a recent extension to full dynamical model (Bergen et al, 2020). Let us first review the RNA metabolic process and its intrinsic dynamics: - RNA is synthesized at a rate of alpha - RNA is spliced to remove introns and reformed into mature mRNA; splicing rate beta - Mature mRNA is degraded after functioning at a rate of gamma In steady state, the unspliced and spliced is at an equilibrium, namely the newly synthesized is exactly equal to the spliced and also the degradated. Therefore, the break of the equilibrium state between unspliced and spliced RNAs is highly informative to indicate whether a gene is in the induction or suppression state. Figure 3.4. RNA kinetics and RNA velocity.Fig. adapted from Haghverdi et al 2016 3.3.1 Unspliced RNA indicates transcriptional speed Usually, the proportion of unspliced RNA is very low in RNA-seq, particularly because most protocols is based on Poly-A enriched RNAs. Namely, in principle, only RNAs reaching 3’ of the gene body can be captured. However, the unspliced RNAs still can be observed at a substantial proportion, usually covering 15-25%. Recently, there are also a few technologies have been introduced to enrich the nascent RNAs in single-cell protocols, e.g., scSLAM-seq and scNT-seq. Though some researchers remain skeptical on the use of RNA velocity, possibly because the high noise-by-signal ratio, the unprecedent capability to automatically detect the trajectory direction attracts much attention. On the other hands, more accurate and robust methods are under rapid development, to make this analysis tool more widely applicable. 3.4 Use scVelo package within R There are two major tools for analysing RNA velocity: velocyto is based on a steady-state model for estimating RNA velocity. It supports both Python and R. scVelo introced an extended dynamical model for estimating RNA velocity, and various of utility functions. However, it only supports Python. Here, we will introduce reticulate to use Python package in R (sounds cool, right, and you will find it handy!) 3.4.1 Environment and preprocessing In order or use scVelo, we need to install it. Please follow Chapter 2.1.2 to install Python and scVelo==0.2.2. As mentioned there, we recommend using Anaconda to create Python and conda environment. Additionally, the extration of unspliced RNA is a bit tricky, and not widely supported. There are three options we have tried (there maybe more, e.g., kallisto bustools): velocyto.py: the earliest software for this purpose. Generally not computationally efficient, possible due to written in Python. For unknown reason, the proportion of unspliced RNA is unrealisticly high for 5’ 10x Genomics data. dropEst: as implemented in C/C++, it is much more efficient. It also returns more reasonable proportion of unspliced RNAs for 5’ 10x Genomics data STAR-solo: new extension for the popular STAR. Benefits: efficient and one step for reads alignment and counting of unspliced RNA (Recommended option) 3.4.2 Getting started First, let’s use load reticulate: # install.packages(&quot;reticulate&quot;) library(reticulate) Then use reticulate to import Python packages scvelo and matplotlib: use_condaenv(&quot;sgcell&quot;) plt &lt;- import(&quot;matplotlib.pyplot&quot;, as = &quot;plt&quot;) scv &lt;- import (&quot;scvelo&quot;) scv$logging$print_version() scv$settings$presenter_view = TRUE scv$settings$verbosity = 3 scv$settings$set_figure_params(&quot;scvelo&quot;) In this tutorial, we will download and use the built-in pancreas dataset to demonstrate the useage of RNA velocity analysis. The dataset will be automatically downloaded to ./data/Pancreas/endocrinogenesis_day15.h5ad (52.5MB). Endocrine development in pancreas lineage has four major fates: \\(\\alpha\\), \\(\\beta\\), \\(\\delta\\), \\(\\epsilon\\). Dataset is obtained and subseted from Bastidas-Ponce et al. (2018) by the scVelo team. In this adata &lt;- scv$datasets$pancreas() adata Note, to run velocity analysis on your own data, read your file with adata = scv$read(file_path). If you want to save model and parameters after processing, run the following command, adata$write(file_path, compression = 'gzip'). Now, let’s have a look of the proportions of unspliced/spliced mRNA reads, UMAP embedding and cluster annotations can be printed and visualized using built-in functions. scv$utils$show_proportions(adata) scv$pl$proportions(adata, figsize=c(10, 3), show=FALSE) plt$savefig(&#39;images/RNA-velo-fig1.png&#39;) RNA-velo-fig2 scv$pl$scatter(adata, legend_loc = &quot;best&quot;, size = 50, title = &quot;Pancreas Celltype&quot;, show=FALSE) plt$savefig(&#39;images/RNA-velo-fig2.png&#39;) RNA-velo-fig2 3.4.3 Data Preprocessing Preprocessing contains: - gene selection by detection (detected with a minimum number of counts) - high variability (dispersion) - normalizing every cell by its initial size and logarithmizing X First and second order moments are also computed (mean, uncentered variance for deterministic, stochastic mode respectively) among nearest neighbors in PCA space. scv$pp$filter_and_normalize(adata, min_shared_counts = as.integer(20), n_top_genes = as.integer(2000)) scv$pp$moments(adata, n_pcs = as.integer(30), n_neighbors = as.integer(30)) 3.4.4 Pseudotime based on Diffusion Map Pseudotime, a part of standardized scRNA-seq analysis pipeline, is also implemented in this package, and can be compared with the colorize(\"latent time\", \"#316A9E\") introduced in dynamical mode. adata$uns$data$iroot &lt;- which.min(adata$obsm[&#39;X_umap&#39;][, 1]) scv$tl$diffmap(adata) scv$tl$dpt(adata) scv$pl$scatter(adata, color = &#39;dpt_pseudotime&#39;, title = &#39;pseudotime&#39;, color_map = &#39;gnuplot&#39;, colorbar = TRUE, rescale_color = c(0,1), perc=c(2, 98), show=FALSE) plt$savefig(&#39;images/RNA-velo-fig3.png&#39;) RNA-velo-fig3 3.4.5 Compute velocity and velocity graph scVelo has incorporated 3 modes for velocity estimation: - Deterministic - Stochastic - Dynamical For deterministic and stochastic mode, the gene-specific velocities are obtained by fitting linear regression ratio (constant transcriptional state) between unspliced/spliced mRNA abundances. Under linear assumptions, how the colorize(\"observed abundances deviate from the steady state\", \"#b22e5b\") regression line is velocity. scv$tl$velocity(adata, mode = &quot;stochastic&quot;) To calculate velocity graph, we need to run colorize(\"velocity_graph()\", \"#316A9E\"). Velocity graph is the cosine correlation of potential cell transitions with velocity vector in high dimensional space. It summarizes the possible cell transition states and has dimension of \\({n}_{obs} * {n}_{obs}\\). scv$tl$velocity_graph(adata, sqrt_transform = TRUE) 3.4.6 Diffusion-map Pseudotime with velocity Pseudotime, a part of standardized scRNA-seq analysis pipeline, is also implemented in this package, and can be compared with the colorize(\"latent time\", \"#316A9E\") introduced in dynamical mode. scv$tl$velocity_pseudotime(adata) scv$pl$scatter(adata, color = &#39;velocity_pseudotime&#39;, cmap = &#39;gnuplot&#39;, show=FALSE) plt$savefig(&#39;images/RNA-velo-fig4.png&#39;) RNA-velo-fig4 scv$pl$scatter(adata, x = &quot;velocity_pseudotime&quot;, y = c(&#39;Actn4&#39;, &#39;Ppp3ca&#39;, &#39;Cpe&#39;, &#39;Nnat&#39;), fontsize = 10, size = 10, legend_loc = &#39;best&#39;, color = &#39;clusters&#39;, figsize=c(12, 10), show=FALSE) plt$savefig(&#39;images/RNA-velo-fig5.png&#39;) RNA-velo-fig5 3.4.7 Plot Results Velocities are projected onto the specified embedding colorize(\"basis\", \"#316A9E\") and can be visualized in one of the three ways: - On single cell level - On grid level - Streamlines, which is most commonly used scv$pl$velocity_embedding_stream(adata, basis = &quot;umap&quot;, color = &quot;clusters&quot;, legend_loc = &quot;best&quot;, dpi = 150, show=FALSE) plt$savefig(&#39;images/RNA-velo-fig6.png&#39;) RNA-velo-fig5 scv$pl$velocity_embedding(adata, basis = &quot;umap&quot;, arrow_length = 3, arrow_size = 2, dpi = 150, show=FALSE) plt$savefig(&#39;images/RNA-velo-fig7.png&#39;) RNA-velo-fig7 3.4.8 Interprete Velocity We could also examine the phase portraits of interested genes to understand how inferred directions are supported by particular genes. scv$pl$velocity(adata, c(&quot;Cpe&quot;, &quot;Gnao1&quot;, &quot;Ins2&quot;, &quot;Adk&quot;), ncols = 2, show=FALSE) plt$savefig(&#39;images/RNA-velo-fig8.png&#39;) RNA-velo-fig8 Positive velocity indicates that a gene is up-regulated, which occurs for cells that show higher abundance of unspliced mRNA for that gene than expected in steady state. Conversely, negative velocity indicates that a gene is down-regulated. 3.4.9 Velocity in cycling progenitors The cell cycle detected by RNA velocity, is biologically affirmed by cell cycle scores (standardized scores of mean expression levels of phase marker genes). scv$tl$score_genes_cell_cycle(adata) scv$pl$scatter(adata, color_gradients = c(&quot;S_score&quot;, &quot;G2M_score&quot;), smooth = TRUE, perc = c(5, 95), legend_loc=&quot;upper center&quot;, show=FALSE) plt$savefig(&#39;images/RNA-velo-fig9.png&#39;) RNA-velo-fig9 3.4.10 Dynamical Mode and related analysis Dynamical mode does not necessarily rely on linear assumptions, instead it consider gene-specific rates of transcription, splicing and degradation rates as well as transient cell-states. To use dynamical mode, we just need to call colorize(\"revocer_dynamics()\", \"#316A9E\") before computing velocity. scv$tl$recover_dynamics(adata) scv$tl$velocity(adata, mode = &quot;dynamical&quot;) scv$tl$velocity_graph(adata) Latent time of the underlying cellular processes can be recovered via dynamical mode. Based on cells’ transcriptional dynamics, latent time approximates the real time experienced by cells as they differentiate. Latent time could distinguish temporal position more compared with pseudotime. scv$tl$latent_time(adata) scv$pl$scatter(adata, color = &quot;latent_time&quot;, color_map = &quot;gnuplot&quot;, size = 80, basis = &quot;umap&quot;) scv$pl$scatter(adata, x = &quot;latent_time&quot;, y = c(&#39;Actn4&#39;, &#39;Ppp3ca&#39;, &#39;Cpe&#39;, &#39;Nnat&#39;), fontsize = 10, size = 10, legend_loc = &#39;best&#39;, color = &#39;clusters&#39;) We could also pull out the top genes driving the dynamic RNA velocities. topgenes &lt;- adata$var[&quot;fit_likelihood&quot;] topgenes_vals &lt;- topgenes[, 1] names(topgenes_vals) &lt;- rownames(topgenes) topgenes_vals &lt;- sort(topgenes_vals, decreasing = TRUE) head(topgenes_vals) scv$pl$scatter(adata, basis = names(topgenes_vals)[1:5], ncols = 5, frameon = FALSE) scv$pl$heatmap(adata, var_names = names(topgenes_vals), tkey = &#39;latent_time&#39;, n_convolve = as.integer(100), col_color = &#39;clusters&#39;) "],["SNV-analysis.html", "Chapter 4 Somatic mutation analysis in single cells 4.1 Introduction 4.2 SNV analysis 4.3 mtSNV analysis", " Chapter 4 Somatic mutation analysis in single cells 4.1 Introduction Whole genome (or exome) sequencing at bulk tissues have been widely used in studying somatic mutation in cancer samples and healthy tissues recently. It allows to identify somatic mutations and accurately estimate of the frequency of each mutation (see Fig. 4.1, adapted from Kuipers et al, 2017). However, there are a few major challenges in somatic mutations with bulk sequencing. First, the allele frequency cannot give accurate clonal structure, as it is difficult to distinct mutations from different clones that have similar population percents. Second, the evolutionary lineage is much difficult to infer from bulk sequencing data without single cell resolution Third, the bulk DNA-seq cannot dissect the phenotypic impact of somatic mutations, which however is crucial to understand intra-tumor heterogeneity, both at genetic and transcriptomic levels. Figure 4.1. Somatic mutations and evolution. Fig adapted from Kuipers et al, 2017 4.1.1 Choice of protocols Let us first review the different protocols for single-cell sequencing, as genetic analysis often higher requirement of sequencing coverage. In next Figure from Ding et al, 2020, there are major two different types of protocols. One is well based, including SMART-seq, returning moderate coverage but low number of cells. The other is droplet-based, including 10x Genomics, returning extremely low coverage but high number of cells. Figure 4.2. Common protocols of scRNA-seq. Fig adapted from Ding et al, 2020 Though scRNA-seq contains the information of somatic mutations in the expressed RNA molecules. However, it only covers the highly expressed genes (or its 3’ / 5’ if UMI-based protocols). Generally, scDNA-seq offers more even coverage across the genome, despite its much higher cost. None the less, given the low capture efficiency, all protocols suffer from allele drop-out, namely false negatives in observing the existing mutation allele. Below, we summarise different sequenciing strategies and their potentials for analysing different types of somatic mutations, including copy number variations (CNV), single-nucleotide variation (SNV) and mitochondrial SNV (mtSNV). Table 4.1. Protocols for cellular genetic analysis In the following sections, we will show two example data sets to illustrating: SMART-seq2 for SNV and mtSNV analysis 10x Genomic for CNV analysis (and possibly mtSNV analysis if lucky) 4.2 SNV analysis Here, we will use a SMART-seq2 dataset, the joxm dataset (77 QC cells) generated from McCarthy et al, 2020), as an example of SNV analsyis in single cells (Fig. 4.3 below for this donor). The processed data sets are directly available from its according cardelino R package. We also prepared the raw data (in .bam format) and scripts to generate them in the Appendix Chapter 7.1 for you to practice the preprocessing steps with tools cellsnp-lit and MQuad. Figure 4.3. SNVs analysis with Joxm dataset. Fig adapted from McCarthy et al, 2020 4.2.1 Call somatic variants and genotype single cells Nuclear genome is large and scRNA-seq is generally noisy, hence making it extremely difficult to call somatic SNVs from scRNA-seq data directly. In this dataset, probably in a general situation, we could detect somatic SNVs using bulk whole genome sequencing with tumor and matched normal samples first, e.g., with the commonly used MuTect. In this joxm dataset, we have called ~650 SNVs from bulk whole exome-seq. Given this list of called somatic variants, we can genotype each cell with genotyping tool. Here, we used our cellsnp-lit (with high recommendation). Finally, we obtained 112 SNVs are expressed in at least one of the 77 cells. The output file in VCF is available in the cardelino package cellSNP.cells.vcf.gz (12KB). 4.2.2 Visualize variat allele fequency Now, let’s load the data and visualise the allele frequency here: library(ggplot2) library(cardelino) vcf_file &lt;- system.file(&quot;extdata&quot;, &quot;cellSNP.cells.vcf.gz&quot;, package = &quot;cardelino&quot;) input_data &lt;- load_cellSNP_vcf(vcf_file) AF &lt;- as.matrix(input_data$A / input_data$D) p = pheatmap::pheatmap(AF, cluster_rows=FALSE, cluster_cols=FALSE, show_rownames = TRUE, show_colnames = TRUE, labels_row=&#39;77 cells&#39;, labels_col=&#39;112 SNVs&#39;, angle_col=0, angle_row=0) Figure 4.4. Allele frequency of somatic SNVs in Joxm dataset As expected, the majority of entries are missing (in grey) due to the high sparsity in scRNA-seq data. For the same reason, even for the non-missing entries, the estimate of allele frequency is of high uncertainty. Therefore, it is crucial to probabilistic clustering with accounting the uncertainty, ideally with guide clonal tree structure from external data. 4.2.3 Use extra information on clonal tree As mentioned, the variant calling is based on bulk WES, which can also be used to infer a clonal tree, even though it is of high uncertainty by only using bulk data. Here, we obtain a maximum-a-posteriori (MAP) tree from Canopy. The clonal tree inferred by Canopy for this donor consists of three clones, including a “base” clone (“clone1”) that has no sublconal somatic mutations present. canopy_res &lt;- readRDS(system.file(&quot;extdata&quot;, &quot;canopy_results.coveraged.rds&quot;, package = &quot;cardelino&quot;)) plot_tree(canopy_res$tree, orient = &quot;v&quot;) Figure 4.5. Clonal tree inferred from bulk WES data 4.2.4 Run cardelino for inferring clonal structure Now, we can leverage the inferred clonal tree as an guidence to cluster cells based on their mutation profiles. Before starting, be careful to ensure that the same variant IDs are used in both data sources. Config &lt;- canopy_res$tree$Z rownames(Config) &lt;- gsub(&quot;:&quot;, &quot;_&quot;, rownames(Config)) The run clone_id the main function in cardelino package: set.seed(7) assignments &lt;- clone_id(input_data$A, input_data$D, Config = Config, min_iter = 800, max_iter = 1200) names(assignments) We can visualise the cell-clone assignment probabilities as a heatmap. prob_heatmap(assignments$prob) Figure 4.6. Assignment probability of cells to clones We recommend assigning a cell to the highest-probability clone if the highest posterior probability is greater than 0.5 and leaving cells “unassigned” if they do not reach this threshold. The assign_cells_to_clones function conveniently assigns cells to clones based on a threshold and returns a data.frame with the cell-clone assignments. df &lt;- assign_cells_to_clones(assignments$prob) head(df) table(df$clone) Also, Cardelino will update the guide clonal tree Config matrix (as a prior) and return a posterior estimate. In the figure below, negative value means the probability of a certain variant presents in a certain clone is reduced in posterior compared to prior (i.e., the input Config). Vice verse for the positive values. heat_matrix(t(assignments$Config_prob - Config)) + scale_fill_gradient2() + ggtitle(&#39;Changes of clonal Config&#39;) + labs(x=&#39;Clones&#39;, y=&#39;112 SNVs&#39;) + theme(axis.text.y = element_blank(), legend.position = &quot;right&quot;) Figure 4.7. Difference between updated and input clonal configuration Finally, we can visualize the results cell assignment and updated mutations clonal configuration at the raw allele frequency matrix: AF &lt;- as.matrix(input_data$A / input_data$D) cardelino::vc_heatmap(AF, assignments$prob, Config, show_legend=TRUE) Figure 4.8. Allele frequency of clustered cells and variants 4.3 mtSNV analysis Recently, mitochondrial variants have also been shown powerful makeups for lineage tracing Ludwig et al, 2019. The much higher copies of mtDNA not only give much higher sequencing coverage, but generally highly mutation rate (probably also some other biological reasons). Figure 4.9. Mitochondrial variants for lineage tracing. Fig. adapted from Ludwig et al, 2019 4.3.1 Visualise allele frequency Here, we illustrate the mtDNA on the joxm dataset again. During the preprocssing, we first genotyping the whole mito genome directly with cellsnp-lit and then call the clonal informed variants by MQuad. Let’s first load the processed dataset from cardelino package and visualise the allele frequency. AD_file &lt;- system.file(&quot;extdata&quot;, &quot;passed_ad.mtx&quot;, package = &quot;cardelino&quot;) DP_file &lt;- system.file(&quot;extdata&quot;, &quot;passed_dp.mtx&quot;, package = &quot;cardelino&quot;) id_file &lt;- system.file(&quot;extdata&quot;, &quot;passed_variant_names.txt&quot;, package = &quot;cardelino&quot;) AD &lt;- Matrix::readMM(AD_file) DP &lt;- Matrix::readMM(DP_file) var_ids &lt;- read.table(id_file, ) rownames(AD) &lt;- rownames(DP) &lt;- var_ids[, 1] colnames(AD) &lt;- colnames(DP) &lt;- paste0(&#39;Cell&#39;, seq(ncol(DP))) AF_mt &lt;- as.matrix(AD / DP) pheatmap::pheatmap(AF_mt) Figure 4.10. Allele frequency of mtDNA variants As expected, the coverage of mtDNA is a lot higher than the nuclear genome above (much fewer missing values). 4.3.2 Infer clonal structure with mtDNA variants Now, we can run cardelino on the mitochondrial variations. Note, as there is no prior clonal tree, the model is easier to return a local optima. Generally, we recommend running it multiple time (with different random seed or initializations) and pick the one with highest DIC. set.seed(7) assign_mtClones &lt;- clone_id(AD, DP, Config=NULL, n_clone = 3, keep_base_clone=FALSE) Then visualise allele frequency along with the clustering of cells and variants: Config_mt &lt;- assign_mtClones$Config_prob Config_mt[Config_mt &gt;= 0.5] = 1 Config_mt[Config_mt &lt; 0.5] = 0 cardelino::vc_heatmap(AF_mt, assign_mtClones$prob, Config_mt, show_legend=TRUE) Figure 4.11. Allele frequency of mtSNVs with clustered cells "],["CNV-analysis.html", "Chapter 5 Copy number variation estimation from scRNA-seq 5.1 Method: inferCNV 5.2 Application on TNBC1 5.3 ref", " Chapter 5 Copy number variation estimation from scRNA-seq Rongting Huang 2021-06-29 5.1 Method: inferCNV InferCNV: Inferring copy number alterations from tumor single cell RNA-Seq data 5.1.1 install inferCNV Software Requirements JAGS R (&gt;3.6) In order to run infercnv, JAGS (Just Another Gibbs Sampler) must be installed. Download JAGS from https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/ and install JAGS in your environment (windows/MAC). If you use inferCNV on server, install JAGS via conda install in your conda environment is recommended. conda install -c conda-forge jags More details refer to inferCNV wiki page Five options for installing inferCNV Option A: Install infercnv from BioConductor (preferred) if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;infercnv&quot;) For more other options, refer to Five options for installing inferCNV Data requirements a raw counts matrix of single-cell RNA-Seq expression an annotations file which indicates which cells are tumor vs. normal. a gene/chromosome positions file File-Definitions 5.1.2 getting started If you have installed infercnv from BioConductor, you can run the example data with: library(infercnv) infercnv_obj = CreateInfercnvObject(raw_counts_matrix=system.file(&quot;extdata&quot;, &quot;oligodendroglioma_expression_downsampled.counts.matrix.gz&quot;, package = &quot;infercnv&quot;), annotations_file=system.file(&quot;extdata&quot;, &quot;oligodendroglioma_annotations_downsampled.txt&quot;, package = &quot;infercnv&quot;), delim=&quot;\\t&quot;, gene_order_file=system.file(&quot;extdata&quot;, &quot;gencode_downsampled.EXAMPLE_ONLY_DONT_REUSE.txt&quot;, package = &quot;infercnv&quot;), ref_group_names=c(&quot;Microglia/Macrophage&quot;,&quot;Oligodendrocytes (non-malignant)&quot;)) infercnv_obj = infercnv::run(infercnv_obj, cutoff=1, # cutoff=1 works well for Smart-seq2, and cutoff=0.1 works well for 10x Genomics out_dir=tempfile(), cluster_by_groups=TRUE, denoise=TRUE, HMM=TRUE) If you can run the getting started part with demo data provided by inferCNV, then it is installed successfully. Demo Example Figure Demo Example Figure 5.2 Application on TNBC1 5.2.1 data description TNBC1 is a triple negative breast cancer tumor sample of high tumor purity (72.6%) with 796 single tumor cells and 301 normal cells. The dataset is available on NCBI GEO under the accession number GSM4476486. Details of TNBC1 dataset (from published articles, copyKAT). TNBC1 Number of clones Number of tumor clones Tumor clone-specific copy gain Triple negative breast cancer 3 2 C1: 4p, 7q, 9, 17q C2: 3p, 6q, 7p, 11q, X Expression Subclusters of TNBC1 dataset (from gene expression analysis-Seurat). Clone A Clone B Normal 488 307 302 Notes: 488,307, 247, 55 umap B Allele Frenquency (BAF) baf1 baf2 baf3 BAF V.S. Expression confusion heatmap 5.2.2 run inferCNV data_download demo1_log_file demo2_log_file output_files # library(infercnv) # library(utils) # library (BiocGenerics) ## DEMO1 # # tnbc &lt;- read.delim(&quot;C://Users/Rongting/Documents/GitHub_repos/combinedTNBC1.txt&quot;) # anno &lt;- tnbc[2,] # anno &lt;- t(anno) # anno &lt;- as.data.frame(anno) # # gex &lt;- tnbc[-c(1:2),] # gex &lt;- type.convert(gex) # # gene_file &lt;- &quot;C://Users/Rongting/Documents/GitHub_repos/gene_note_noheader_unique.txt&quot; # # infercnv_obj = CreateInfercnvObject(raw_counts_matrix=gex, # annotations_file=anno, # delim=&#39;\\t&#39;, # gene_order_file=gene_file, # ref_group_names= &quot;N&quot;) # output = &quot;C://Users/Rongting/Documents/GitHub_repos/tnbc1_demo&quot; # infercnv_obj = infercnv::run(infercnv_obj, # cutoff=0.1, # out_dir= output , # cluster_by_groups=T, # denoise=T, # HMM=T) ## DEMO2 # gene_file &lt;- &quot;C://Users/Rongting/Documents/GitHub_repos/gene_note_noheader_unique.txt&quot; # # anno_file &lt;- &#39;C://Users/Rongting/Documents/GitHub_repos/tnbc-3cluster-id.txt&#39; # # infercnv_obj2 = CreateInfercnvObject(raw_counts_matrix=gex, # annotations_file=anno_file, # delim=&#39;\\t&#39;, # gene_order_file=gene_file, # ref_group_names= &quot;Normal&quot;) # # output = &quot;C://Users/Rongting/Documents/GitHub_repos/tnbc1_demo2&quot; # # infercnv_obj2 = infercnv::run(infercnv_obj2, # cutoff=0.1, # out_dir= output, # cluster_by_groups=T, # denoise=T, # HMM=T) ################# ##Notes ################# ## load the package library(Seurat) library(infercnv) ## prepare the data (cellranger output) ### load count matrix (example) matrix_path &lt;- &quot;../cellranger/xxxx/count_xxxxx/outs/filtered_gene_bc_matrices/GRCh38/&quot; ### read count matrix gex_mtx &lt;- Seurat::Read10X(data.dir = matrix_path) ### run inferCNV with loop celltype = c(&#39;CloneA&#39;, &#39;CloneB&#39;, &#39;Normal&#39;) for (i in celltype){ infercnv_obj1 = CreateInfercnvObject(raw_counts_matrix=gex_mtx, annotations_file=anno_file, delim=&#39;\\t&#39;, gene_order_file=gene_file, ref_group_names=c(i)) output &lt;- paste0(&#39;/groups/cgsd/rthuang/processed_data/inferCNV/xxxx/&#39;,&#39;xxxx_&#39;, i) infercnv_obj1 = infercnv::run(infercnv_obj1, cutoff=0.1, out_dir= output , cluster_by_groups=T, denoise=T, HMM=T) } 5.2.3 inferCNV result demo1 infercnv1 infercnv2 demo2 infercnv3 infercnv4 5.3 ref https://www.r-bloggers.com/2012/04/getting-started-with-jags-rjags-and-bayesian-modelling/ bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],["preprocess.html", "Chapter 6 Preprocessing of dataset 6.1 Preprocessing for RNA Velocity 6.2 Preprocessing for somatic mutation analysis 6.3 (Optional) Install Windows Subsystem for Linux", " Chapter 6 Preprocessing of dataset 6.1 Preprocessing for RNA Velocity Author: “Chen Qiao” Date: “7/2/2021” In this tutorial, we would take the Pancreas dataset used in scVelo paper for example, show how to retrieve the fastq dataset from NCBI, process using cellranger, velocyto or dropest to obtain the spliced and unspliced count matrices for RNA velocity estimation. 6.1.1 List of packages aligned in pipeline: SRATool: for downlowding datasets from NCBI, Pancreas dataset E15_5 with SRA id SRR9201794 Cellranger: for counting, analyzing, QA on fastqs, outputs input for velocyto/dropest Alternative tools for counting spliced and unspliced reads from Cellranger outputs/ Velocyto samtools: Velocyto’s dependency pakcage dropest 6.1.2 Installation of packages/softwares All the codes are executed on Linux commandline, lines starting with “#” are comments. My working path root is “/data/users/cqiao/share/,” you may change to any foler as you like. 6.1.2.1 SRATool Refer to This tutorial for step 3. software configuration # 1. download software wget http://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/current/sratoolkit.current-ubuntu64.tar.gz # 2. extract package tar -xzf sratoolkit.tar.gz # 3. configuration software ./sratoolkit.2.11.0-ubuntu64/vdb-config --interactive # 4. add software to system path so that we can easily call it export PATH=$PATH:/data/users/cqiao/share/sratoolkit.2.11.0-ubuntu64/bin/ # 5. test installation, expected to output some sequencing results fastq-dump --stdout -X 2 SRR390728 6.1.2.2 Cellranger # 1. download software wget -O cellranger-6.0.2.tar.gz &quot;https://cf.10xgenomics.com/releases/cell-exp/cellranger-6.0.2.tar.gz?Expires=1625079682&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jZi4xMHhnZW5vbWljcy5jb20vcmVsZWFzZXMvY2VsbC1leHAvY2VsbHJhbmdlci02LjAuMi50YXIuZ3oiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MjUwNzk2ODJ9fX1dfQ__&amp;Signature=Ez05ie1~xJTrUhsc3Q1nZ3JemF5Jc2k3zOOC2PlJiI80TI8YOxM3vVXli90ib1Kl4WgQFRl5~Wp-ce5m2gVAyywGf9juiMk3kW2WGz7xy3DN9nCG-he0rNLvbknDXgkqkj8HeirWyt-EvGgsaqBRZZx7GppGl~MGQOseLTF7DMpJaIm-qwU-72mkVzDy0vKrYVZ~Uiqnlr0M2Hhx14lPwm6QocBuSaKLkmcuZosN4TIS05Z~GPHYt9hQWkykvY4oyd5Y~tyTaMOM8ozVVdI7KgCfc2PmQvhr1bMuhUaEPa3skigzAFjIezbw-fXW3Z8jplwj4lAQ0LybI03ozZr6jg__&amp;Key-Pair-Id=APKAI7S6A5RYOXBWRPDA&quot; # 2. extract files tar -xzf cellranger-6.0.2.tar.gz # 3. add software to system path so that we can easily call it export PATH=$PATH:/data/users/cqiao/share/cellranger-6.0.2 # 4. download gene refereces (optional saving path: ./cellranger/gtfs/) cd cellranger-6.0.2 mkdir gtfs cd gtfs # human (optional for your needs) wget https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-GRCh38-2020-A.tar.gz tar -xzf refdata-gex-GRCh38-2020-A.tar.gz # mouse (we shall use this for Pancreas dataset) wget https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2020-A.tar.gz tar -xzf refdata-gex-mm10-2020-A.tar.gz 6.1.2.3 Velocyto &amp; Samtools 6.1.2.3.1 Samtools # 1. download &amp; extract software wget https://github.com/samtools/samtools/releases/download/1.12/samtools-1.12.tar.bz2 tar -jxvf samtools-1.12.tar.bz2 cd samtools-1.12 # 2. configure build, specify --prefix to locate the root dir ./configure --prefix=/data/users/cqiao/share/samtools # 3. compile and install software make make install # 4. add software to system path so that we can easily call it PATH=$PATH:/data/users/cqiao/share/samtools/bin/ # go back to parant folder cd .. 6.1.2.3.2 Velocyto Assume your python packages are managed by conda and pip # install dependent packages, may also use pip conda install numpy scipy cython numba matplotlib scikit-learn h5py click # install velocyto pip install velocyto 6.1.2.4 Dropest Install dependent libraries Install RPackages (in R) install.packages(c(&quot;Rcpp&quot;,&quot;RcppEigen&quot;, &quot;RInside&quot;, &quot;Matrix&quot;)) Setup a local lib path: export LOCAL_LIBS=/data/users/cqiao/share/local mkdir $LOCAL_LIBS export PATH=$LOCAL_LIBS/bin:$LOCAL_LIBS/usr/local/bin/:$PATH Install CMake wget https://cmake.org/files/v3.12/cmake-3.12.0-rc1.tar.gz tar xvf cmake-3.12.0-rc1.tar.gz cd cmake-3.12.0-rc1 ./bootstrap --prefix=$LOCAL_LIBS make make install cd .. Zlib wget https://zlib.net/zlib-1.2.11.tar.gz tar xvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure --prefix=$LOCAL_LIBS make make install cd .. BamTools git clone https://github.com/pezmaster31/bamtools.git cd bamtools mkdir build &amp;&amp; cd build cmake ../ make make install DESTDIR=$LOCAL_LIBS cd .. Bzip2 wget https://www.sourceware.org/pub/bzip2/bzip2-latest.tar.gz tar -xzvf bzip2-latest.tar.gz cd bzip2-1.0.8 make -f Makefile-libbz2_so make install PREFIX=$LOCAL_LIBS cp -a libbz2.so* $LOCAL_LIBS/lib/ ln -s $LOCAL_LIBS/lib/libbz2.so.1.0 $LOCAL_LIBS/lib/libbz2.so cd .. Boost wget http://sourceforge.net/projects/boost/files/boost/1.60.0/boost_1_60_0.tar.gz tar xzf boost_1_60_0.tar.gz cd boost_1_60_0 ./bootstrap.sh ./b2 cxxflags=&quot;-std=c++11&quot; include=&quot;$LOCAL_LIBS/include/&quot; search=&quot;$LOCAL_LIBS/lib/&quot; link=shared threading=multi install --prefix=$LOCAL_LIBS cd .. DropEst git clone https://github.com/hms-dbmi/dropEst.git mkdir dropEst/build cd dropEst/build cmake -D CMAKE_INSTALL_PREFIX=&quot;/data/users/cqiao/share/dropesttool&quot; .. &amp;&amp; make export PATH=$PATH:/data/users/cqiao/share/dropesttool/bin/ 6.1.3 Preprocessing pipline 6.1.3.1 1. Download and split Pancreas E15_5 fastq data from NCBI: fasterq-dump --split-files SRR9201794 Result would be: SRR9201794_1.fastq SRR9201794_2.fastq Rename files for cellranger: mv SRR9201794_1.fastq SRR9201794_S1_L001_R1_001.fastq mv SRR9201794_2.fastq SRR9201794_S1_L001_R2_001.fastq Optinally, move them to a folder /data/users/cqiao/share/E15_5 6.1.3.2 2. Run Cellranger count, referring to the mouse refdata cellranger count --id=pancreas_E15_5 \\ --fastqs=/data/users/cqiao/share/E15_5 \\ --transcriptome=/data/users/cqiao/share/cellranger-6.0.2/gtfs/refdata-gex-mm10-2020-A --id specifies the output dir, the output root. 6.1.3.3 3. Run Velocyto/Dropest. prepare some variables to store path names, so that afterwards we do not need to use the long names. # Barchodes if cellranger output files: gzip -d ./pancreas_E15_5/outs/filtered_feature_bc_matrix/barcodes.tsv.gz BARCODES=./pancreas_E15_5/outs/filtered_feature_bc_matrix/barcodes.tsv # Bam file BAMFILE=./pancreas_E15_5/outs/possorted_genome_bam.bam # transcriptome reference GTF=/data/users/cqiao/share/cellranger-6.0.2/gtfs/refdata-gex-mm10-2020-A/genes/genes.gtf Velocyto velocyto run -b $BARCODES -o ./velocyto_res $BAMFILE $GTF Results are stored in ./velocyto_res/XXX.loom Dropest Requires a .xml configuration file specifying the platform settings for sequencing data. Template configure file could be downloaded here. We shall use 10x.xml for Pancreas E15_5 dataset. Replace line 64 with the path of 10x.xml: ... &lt;barcodes_file&gt;./pancreas_E15_5/outs/filtered_feature_bc_matrix/barcodes.tsv&lt;/barcodes_file&gt; ... Then execute the following code: $bin/dropest -f -V -g $GTF -c $config_file $BAMFILE Results are stored in file ./pancreas_E15_5/dropEst/cell.counts.matrices.rds. 6.2 Preprocessing for somatic mutation analysis 6.2.1 Pileup with cellsnp-lite Cellsnp-lite is designed to perform efficient pileup and genotyping for both bulk and single cell sequencing data. It could be easily installed via conda with conda install -c bioconda -c conda-forge cellsnp-lite. Note that, cellsnp-lite does not support Windows, but you can use it with the help of the Windows Subsystem for Linux (WSL). Details about WSL can be found in section below. We use a SMART-seq2 dataset as an example, which were packed into joxm.bam.all.77.tar.gz (77 bam files, ~3.5G in total; McCarthy et al, 2020). First, please download joxm.bam.all.77.tar.gz, joxm.hg19.bam.lst and joxm.sample.lst from sgcellworkshop repo on sourceforge. Put the three files in the same directory. Then unpack the bam files with command tar zxvf joxm.bam.all.77.tar.gz. The bam files, together with the .bai files, should be in the sort/ directory. 6.2.1.1 Pileup without given SNPs In this example, we use cellsnp-lite to pileup chrM on the bam files without a given SNP list (in denovo mode), whose output could be used as inputs of MQuad model for mitochondrial clone analysis. Note that the pileup results joxm.hg19.cellsnp.mode2b.tar.gz can be downloaded from sgcellworkshop repo on sourceforge and then unpacked with command tar zxvf joxm.hg19.cellsnp.mode2b.tar.gz. The command line to generate the results is, cellsnp-lite \\ -S ./joxm.hg19.bam.lst \\ -i ./joxm.sample.lst \\ -O ./cellsnp2b \\ --chrom MT \\ --cellTAG None \\ --UMItag None \\ --minCOUNT 20 \\ --minMAF 0 \\ --genotype \\ --gzip 6.2.1.2 Pileup with given SNPs This time, we use cellsnp-lite to pileup given SNPs on the bam files. The 112 SNPs, stored in joxm.hg19.somatic.sites.vcf, were somatic SNPs called in (McCarthy et al, 2020) and can be downloaded from sgcellworkshop repo. Note that the pileup results joxm.hg19.somatic.cellsnp.mode1b.tar.gz can be downloaded from sgcellworkshop repo on sourceforge and then unpacked with command tar zxvf joxm.hg19.somatic.cellsnp.mode1b.tar.gz. The command line to generate the results is, cellsnp-lite \\ -S ./joxm.hg19.bam.lst \\ -i ./joxm.sample.lst \\ -O ./cellsnp1b \\ -R ./joxm.hg19.somatic.sites.vcf \\ --cellTAG None \\ --UMItag None \\ --minCOUNT 0 \\ --minMAF 0 \\ -p 4 \\ --genotype \\ --gzip 6.2.2 Clonal analysis with MQuad 6.3 (Optional) Install Windows Subsystem for Linux Note, this is for Windows users only. While some required softwares only support Linux or macOS, you could install WSL to use Linux inside Windows. The whole process of installing WSL requires at least 2G disk space. Note that this process was tested on Windows 10 (Version 2004, build 19041.1052). 6.3.1 What is the Windows Subsystem for Linux (WSL)? According to the Microsoft Docs, “The Windows Subsystem for Linux lets developers run a GNU/Linux environment – including most command-line tools, utilities, and applications – directly on Windows, unmodified, without the overhead of a traditional virtual machine or dualboot setup.” 6.3.2 Manual Installation Steps Step 1. Enable required feature in Windows PowerShell It is necessary to enable the required feature for WSL before installing it. Type powershell in the search box of the Windows taskbar. Right click Windows PowerShell and select Run as administrator. Type the command below in PowerShell. dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Step 2. Download and install WSL Microsoft now supports several Linux distributions as WSL, such as Ubuntu, openSUSE, Fedora, etc (a full list here), among which we choose Ubuntu as an example. Ubuntu WSL could be freely downloaded and installed through Microsoft Store. Go to the webpage for Ubuntu in Microsoft Store. Click on the Get button. Wait for completion of downloading and installation. Click on the Launch button. Step 3. Create a new account for Ubuntu After successfully installing Ubuntu, a new user account should be created. Type user name and password following the prompts on the screen. Note, it is normal that the password is invisible when you are typing. Now Congratulations! You have successfully installed and set up Ubuntu in your Windows System! Next time you can re-open Ubuntu through the search box of the Windows taskbar. More information about the usage of WSL can be found at Microsoft Docs. "],["references.html", "References", " References "]]
